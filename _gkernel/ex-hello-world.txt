"hello"
push {r11,lr}
- 스택에 lr,r11 순으로 저장

add r11,sp,#8
- r11에 sp+8를 저장

sub sp,sp,#8
- sp를 8바이트 만큼 뺀다

str r0,[r11,#-8]
- (r11-8) 번지에 r0값을 넣어준다

str r1,[r11,#-12]
- sp-8에 main함수의 두번째 인작값을 넣는다

ldr r0,[pc,#16] ;0x10430<main+44>
- r0에 *(pc+16)을 넣는다 
- *(pc+16) 는 "hello, world\n"가 들어있는 문자열
- 여기서 0x10430은 문자열을 가르키는 주소이다

bl 0x102e4 <puts@plt>
- lr에 puts@plt 명령어의 주소를 저장

mov r3,#0
- r3에 0을 집어넣는다

mov r0,r3
- r0에 r3을 집어넣는다

sub sp,r11,#4
-sp에 r-4의 값을 넣어준다

pop {r11,pc}
- pc와 r11에 각각 pop을 한다

muleq r0,r1,r4, lsr #9 
- r0에 r0을 논리 오른쪽 논리 쉬프트를 9만큼 하고 집어넣기
- r4*r1==r0 비교




printf 함수 호출 ->  plt로 이동 -> got 참조




readelf -S ./실행파일 
사용되는 함수를 봄
.plt 102d0
.got 21000

0x1041c bl 0x102e4 <puts@plt>
 - 0x102e4 주소 실행 <함수명@plt>

x/3i 0x102e4 
 - 0x102e4 0x102e8 0x102ec 출력

0x102ec ldr pc,[r12,#3360]!
- pc가 r12+3360 가르키게 함

b* 0x1041c
- 브레이크 포인트를 0x1041c 로 설정 후 실행
- 0x1041c 에서 puts 로 진입해서 레지스터 값을 봐야해서

stepi 
- puts 로 진입
- 2번 더 실행
-  현재 위치가 0x102ec 로이동

info reg
 - r12의 주소 0x202ec
 - 0x202ec +d20(3360) 계산 = 0x2100c
 

x/3i 0x2100c
 -0x2100c puts@got.plt
 - 0x21010 __libc_start_main
 
b main
layout asm 
layout reg 
훨씬 편함


	<puts@plt>
	<_dl_runtime_resolve>
	<__GI__IO_puts>
	<main>
	<__libc_start_main>


