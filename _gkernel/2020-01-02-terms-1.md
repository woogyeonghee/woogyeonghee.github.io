---
layout: post
title: ARM architecture 2s
tags: 
- text
---



# 2 terms of arm architecture



### 2.1 ARMV8



### 2.1.1 익셉션

- armv8의 프로세서는 4개의 익셉션 레벨이 존재 (EL0,EL1,EL2,EL3).

- 레벨이 높을수록 자원에 대한 접근권한도 높아짐
- EL0은 유저 애플리케이션, EL1은 커널, EL2는 하이퍼바이저, EL3는 보안 모니터

### 2.1.2 실행 상태

- AArch 64, AArch32 실행 상태로 나뉨







### 2.2 레지스터



### 2.2.1 프로세서 상태 레지스터

- 프로세서 상태를 저장하는 레지스터



### 2.2.2 특수 목적 레지스터

###  2.2.2.1 프로그램 카운터 (PC)

- 다음 실행할 인스트럭션의 위치를 저장하는 레지스터

###  2.2.2.2 익셉션 링크 레지스터 (ELR)

- 익셉션 복귀시 돌아갈 실행 위치 저장 레지스터

###  2.2.2.3 프로세스 상태 저장 레지스터 (SPSR)

- 특정 시점의 프로세스 상태를 저장하는 레지스터

###  2.2.2.4 제로 레지스터 (ZR)

- 소스 레지스터로 사용시 0
- 목적 레지스터로 사용시 결과값 버려짐
- XZR: 64비트, WZR: 32비트

###  2.2.2.5 스택 포인터 (SP)

- 스택의 현재 위치를 가리키는 레지스터



### 2.2.3 시스템 레지스터

- AArch64 시스템 설정을 제어하는 레지스터
- MRS TTBRO_EL1에서 레지스터로 읽어올때
- MSR 레지스터에서 TTBRO_EL1_로 쓸때



### 2.2.4 ABI 레지스터

- AArch64 시스템 설정을 제어하는 레지스터

### 2.2.4.1 파라미터 레지스터 (X0~X7)

- 함수 호출시 파라미터를 전달하는 레지스터

### 2.2.4.2 호출자 저장 임시 레지스터 (X9~X15)

- 레지스터가 보존될때 호출자가 자신의 스텍프레임에 저장하기 하기위해 쓰이는 레지스터

### 2.2.4.3 피호출자 저장 레지스터 (X19~X29)

- 호출된 함수가 복원될때 쓰이는 레지스터

### 2.2.4.4 특수 목적 레지스터(X8,X16~X17,X18,X29,X30)

###  2.2.4.4.1 간접결과 위치 레지스터 (X8)

- 주소의 위치 전달하는데 사용

###  2.2.4.4.2 인프라 프로시저 레지스터 (IP0,IP1) (X16~17)

- 서브루틴 호출 사이의 중간 값을 위한 임시 레지스터

###  2.2.4.4.3 플랫폼 레지스터 (X18)

- 플랫폼 ABI로 사용

###  2.2.4.4.4 프레임 포인터 레지스터 (X29)

###  2.2.4.4.5 링커 레지스터 (LR) (X30)







### 2.3 익셉션 핸들링

- 익셉션을 처리하고 익셉션 발생 전의 상태에서 실행을 재개



### 2.3.1 익셉션 타입

### 2.3.1.1 서비스 호출 인스트럭션 인셉션

- 소프트웨어에서 좀저 높은 특권 레벨에서 동작하는 서비스를 요청하기 위해 호출

###  2.3.1.1.1 슈퍼바이저 콜 (SVC) 

- 유저 모드 프로그램에서 OS 서비스를 요청할 때 쓰임

###  2.3.1.1.2 하이퍼바이저 콜 (HVC) 

- 게스트 OS에서 하이퍼바이저 서비스를 요청할 때 쓰임

###  2.3.1.1.3 보안 모니터 콜 (SMC) 

- 일반구역에서 보안구역 서비스를 요청할 때 쓰임

### 2.3.1.2 abort 익셉션

###  2.3.1.2.1 인스트럭션 abort 

- 인스트럭션 fetch가 실패할 경우 발생

###  2.3.1.2.2 데이터 abort 

- 데이터 접근 실패할 경우 발생

### 2.3.1.3 리셋 익셉션 

- 코어에 리셋이 입력될때 발생하는 익셉션

### 2.3.1.4 인터럽트 익셉션

- IRQ
- FIQ: 우선순위 높음



### 2.3.2 동기 및 비동기 익셉션

### 2.3.2.1 동기 익셉션

- 인스트럭션 실행 또는 실행 시도의 결과로 발생

### 2.3.2.2 비동기 익셉션

- 인스트럭션 실행과 무관



### 2.3.3 익셉션 핸들링



### 2.3.4 익셉션에 의해 변경되는 실행 상태와 익셉션 레벨



### 2.3.5 익셉션 벡터 테이블

- 익셉션 발생시 익셉션에 대응하는 약속된 위치의 핸들려 코드를 수행한다 이때 핸들러가 저장된 메모리 영역을 익셉션 벡터 테이블이라고 한다



### 2.3.6 인터럽트 핸들링

- 인터럽트 시그널을 말함 



### 2.3.7 GIC 표준 인터럽트 핸들러

- 인터럽트 소스를 관리하고 각 코어로 인터럽트를 라우팅하고 우선순위를 정할수 있다



### 2.4 캐시

- 코어와 메인 메모리 사이에 위치한 작고 빠른 메모리
- 접근 속도가 느림 메인 메모리의 사본을 일부 유지한다



### 2.4.1 캐시 구조 

###  2.4.1.1 태그

- 캐시 탐색시 저장되는 메모리 주소의 일부

###  2.4.1.2 캐시 라인

- 여러 워드를 묶은 블록

###  2.4.1.3 인덱스

- 캐시 라인을 찾기 위해 사용되는 메모리 주소의 일부 비트

###  2.4.1.4 웨이와 세트

- 웨이: 캐시 탐색 과정에서 태그가 일치할 확률을 높이기 위해 동일한 인덱스에 해당하는 태그/캐시라인 을 두는데 태그/캐시 라인 각각을 웨이라고 한다
- 세트: 각웨이에서 같은 인덱스를 사용하는 캐시 라인의 묶음

###  2.4.1.5 오프셋

- 주소의 하위 몇 비트, 캐시라인을 찾은뒤 해당 캐시라인에 접근할 바이트 위치저장



### 2.4.2 캐시 컨트롤러

- 캐시를 관리하는 하드웨어 메인메모리와 캐시사이의 코드롸 데이터 읽기 쓰기를 담당



### 2.4.3 캐시 정책

- 캐시 라인을 언제 할당할지, 데이터 캐시에 저장 인스트억션이 발생할 떄 어떤 동작을 할지를 결정

###  2.4.3.1 write-back 정책

- 쓰기 요청이 오면 캐시라인까지만 갱신하고 더티 비트를 설정
- 더티비트는 캐시라인이 메인 메모리의 내용과 일치하지 않는 상태를 나타내는 비트

###  2.4.3.2 write-through 정책

- 쓰기 시 캐시와 외부메모리 함께 갱신한다 
- 더티비트 설정안함



### 2.4.4 캐시 일관성의 두 관점

###  2.4.4.1 Poc

- 특정 주소에 대해 다른 코어,DSP,DMA처럼 메모리에 접근할 수 있는 모든 옵저버가 동일한 메모리 사본을 볼 수 있도록 보장한다

###  2.4.4.2 Pou

- 코어에서 인스트럭션 캐시, 데이터 캐시 , TBL등이 동일한 메모리 사본을 볼 수 있도록 보장한다



### 2.4.5 캐시 관리



### 2.4.6 캐시 탐색

- 세트와 웨이 또는 가상 주소를 지정해서 동작한다
- 이를 위한 캐시 관련 레지스터들이 제공한다

### 
