---
layout: post
title: terms of arm architecture 2
tags: 
- text
---

### 2.5 MMU

- 코어에서 발생하는 가상주소를 물리주소로 변환한다



### 2.5.1 가상 주소를 물리 주소로 변환

### 2.5.2 AArch64의 테이블 디스크립터 종류

- 변환 테이블의 디스크립터는 레벨 수와 변환 단위 크키에 따라 테이블이 나타낼 수 있는 주소 범위가 달라진다

###  2.5.2.1 테이블 디스크립터와 테이블 엔트리

- 테이블 디스크립터가 레벨 0,1,2 에서 사용되는 경우 다음 레벨의 테이블 주소를 나타낸다
- 레벨 3에서 사용하는 경우 페이지 디스크립터 엔트리로 사용된다

###  2.5.2.2 블록 엔트리

- 레벨 1,2에서 사용되며 블록주소를 변환한다
- 레벨ㄹ 3에서 사용되는 경우 변환 폴트가 발생한다

###  2.5.2.3 invalid 엔트리

- 어느 레벨에서든 사용 가능하며 접근시 변환 폴트가 발생한다



### 2.5.3 커널과 애플리케이션의 가상 주소 공간 분리

- 커널의 주소 공간 TTBR1이 가르키는 변환테이블 사용
- 유저의 주소 공간 TTBR0가 가르키는 변환 테이블 사용



### 2.5.4 변환 테이블의 cacheable과 shareable 속성

- cacheable 
- shareable 속성은 페이지 테이블 탐색과 관련된 메모리 영역이 다른 에이전트 간에 공유가 가능한지 여부를 결정



### 2.5.5 디스크립터 메모리 속성

### 2.5.5.1 메모리 영역의 액세스 원한

### 2.5.5.2 OS의 변환 테이블 디스크립터 사용



### 2.5.6 시큐리티와 MMU



### 2.5.7 컨텍스트 스위칭







### 2.6 메모리 오더링



### 2.6.0.1 인스트럭션 다중 발생

- 프로그램 순서대로 인스크억션들이 동시에 실행될수 있다

### 2.6.0.2 비순차 실행

- 의존성이 없는 인스트럭션들의 실행 순서를 바꿔 실행순서를 바꿔 실행하는 기법이다

### 2.6.0.3 예측 실행

- 명령을 수행할 조건이 성립되기 전에 명령을 실행하는 것을 말한다

### 2.6.0.4 예측 로딩

- cacheable 메모리에 대해 읽기 인스트럭션이 요청괼 경우 예측해서 로딩하는 기법이다

###  2.6.0.5 읽기/쓰기 최적화

- 여러번의 쓰기를 하나의 긴 트랜잭션으로 처리해 전송횟수를 줄일 수 있다

### 2.6.0.3 버스 컨트롤러의 트랜잭션 재배치

- 다른 마드터들에서의 접은이 완료될 때까지 가변 사이클이 필요하거나 서로를 앞지를 수 있다

### 2.6.0.4 하드웨어에 의한 캐시 일관성

- smp에서 캐시 일관성 하드웨어는 코어들 사이에 캐시 라인을 이전할 수 있다



### 2.6.1 메모리 타입

### 2.6.1.1 normal 메모리

- 메모리 상의 코드 영역과 대부분의 데이터 영역이 normal 메모리 타입니다

###  2.6.1.2 device 메모리

###  2.6.1.2.1 gathering 또는 non gathering 

- 해당 주소 영역에 대한 여러번의 접근이 1개의 버스 트랜잭션으로 합쳐질 수 있는가를 결정한다

###  2.6.1.2.2 re-ordering

- 동일 디바이스에 대한 접근이 재배치될 수 있는 지를 결정한다

###  2.6.1.2.3 early write acknowledgement

- 프로세소와 디바이스 사이의 쓰기 버퍼에서 쓰기 완료 응답을 보낼 수 있는지 결정한다



### 2.6.2 배리어

### 2.6.2.1 ISB

- 파이프라인에 들어있는 인스트럭션들을 방출하고 현채의 컨텍스트로 인스트럭션을 fetch한다

###  2.6.2.2 DMB

- 데이터 접근 인스트럭션이 배리어 인스트러션을 가로질러 재배치되는 것을 막는다

### 2.6.2.1 DSB

- 오더링을 강제할 뿐만 아니라 동기화가 완료될 떄까지 모든 추가적인 인스트럭션이 실행되는 것을 막는다

###  

### 2.6.3 메모리 속성

### 2.6.3.1 cacheable 과 shareable 메모리 속성

###  2.6.3.1.1 비공유

- 하나의 프로세서나 에이전트에 의해서만 접근 가능한 메모리를 나타낸다

###  2.6.3.1.2 내부 공유가능

- 멀티프로세서들 사이에는 공유될 수 있지만 시스템의 다른 에이전트롸는 공유할 필요가 없는 메모리를 나타맨다

###  2.6.3.1.3 외부 공유기능

- 하나 이상의 내부 공유가능 도메인과 다수의 에이전트들로 구성되어 공유되는 메모리를 나타낸다

###  2.6.3.1.4 전체 시스템

- 인스트럭션이 시스템의 모든 옵저버에게 영향을 미친다



###  2.7 멀티코어 프로세서

### 2.7.1 멀티프로세싱 시스템 (SMP)

###  2.7.1.1 멀티코어 프로세서의 분류

- 동종 멀티코어
- 이기종 멀티코어

###  2.7.1.2 멀티프로세싱 시스템의 분류

###  2.7.1.2.1 SMP

- 개별 코어의 역할이 동적으로 결정되는 소프트웨어 아키텍쳐

###  2.7.1.2.2 AMP

- 코어들이 독자적인 역할을 담당하는 소프트웨어 아키텍쳐

###  2.7.1.2.3 HMP

- 다른 종류의 프로세서들을 사용한 시스템

###  2.7.1.3 동기화 이슈

- 테스크가 동시에 실행됨으로 공유 자원에 대한 동시접근으로 동기화가 깨지는 문제가 발생할 수 있다

###  2.7.1.3.1 배타적 모니터

- 각 코어마다 로컬 모니터가 있으며 시스템에 하나 이상의 글로벌 모니터가 있다

###  2.7.1.3.2 타이머

- 각 코에에서 주기적으로 인터럽트를 발생시켜 스케줄러가 다음에 실행할 태스크를 선택할 기회를 준다



### 2.7.2 캐시 일관성



### 2.7.3 클러스터 내의 멀티코어 캐시 일관성

###   2.7.3.1캐시 일관성을 위한 메커니즘

###   2.7.3.1.1 소프트웨어 관리 일관성

- 디바이스 드라이버 등에서 명시적인 코드로 더티 데이터를 클린하거나 무효화하는 것

###   2.7.3.1.2 하드웨어 관리 일관성

- 클러스터 내 L1 데이터 캐시 사이의 일관성을 관려 한다

###   2.7.3.2 MOESI 프로토콜의 상태

- M : 수정 캐시라인이 최신 데이터를 갖고 있다
- O :  소유 캐시라인이 더티이며 여러 캐시에 존재할 수 있다
- E : 독점 캐시라인이 이캐시에 존재하며 메인메모리와 데이터가 같다
- S : 공유 캐시라인이 이캐시에 존재하며 메모리와 같을 필요는 없다
- I : 무효 캐시라인이 유효하지 않다

###   2.7.3.3 그 밖의 캐시 일관성



### 2.7.4 버스 프로토콜과 캐시 일관성 인터커넥트







###  2.8 전력관리

###  2.8.1 유휴 상태 관리

###  2.8.1.1 전력 및 클록 관리

###   2.8.1.1.1 스텐바이 모드

- 코어의 전원은 공급된 상태지만 클록들의 대부분은 정지되거나 클록 케이팅 상태로 남아있다

###   2.8.1.1.2 리텐션 모드

- 디버그 설정을 포함한 코어 상태가 저전력 구조로 유지되며 코어가 최소한 부분적으로 꺼질 수 있다

###   2.8.1.1.3 파워 다운 모드

- 코어의 전원이 꺼진다

###   2.8.1.1.4 휴먼 모드

- 파워 다운 상태의 한 구현 방식이다 코어 로직의 전원은 차단되지만 캐시와 RAM 의 전원은 유지된다

###   2.8.1.1.5 핫플러그

- 동적으로 코어들을 켜고 끌수 있는 기능



###  2.8.2소비 전류 관련 인스트럭션



###  2.8.3 PSCI
